1.4
-- 'Долю пользователей, сделавших в этот день...`. А вы считаете нарастающим итогом пользователей.
-- долго смотрел и не видел, что человек считает не тот показатель. Читать условие задачи.
WITH tab1 AS ( -- дата, число пользователей нарастающим итогом
  SELECT
    date,
    SUM(paying_users) OVER(
      ORDER BY
        date
    ):: integer AS total_users
  FROM
    (
      SELECT
        date,
        count(user_id) as paying_users
      FROM
        (
          SELECT
            time :: date as date,
            user_id
          FROM
            user_actions
          WHERE
            order_id not in (
              SELECT
                order_id
              FROM
                user_actions
              WHERE
                action = 'cancel_order'
            )
          GROUP BY
            date,
            user_id
          ORDER BY
            date,
            user_id
        ) t1 -- дата, юзер для неотмененнных
      GROUP BY
        date
    ) z1 -- дата, число пользователей
),

tab2 AS ( -- , дата, количество однозаказников нарастающим итогом
  SELECT
    DISTINCT date,
    COUNT(daily_orders_count) OVER (
      ORDER BY
        date
    ) AS single_order_users ,
    COUNT(*) OVER (
      ORDER BY
        date
    ) total_users
  FROM
    (
      SELECT
        DISTINCT user_id,
        time :: date AS date,
        COUNT(user_id) OVER(PARTITION BY user_id, time :: date) AS daily_orders_count
      FROM
        user_actions
      WHERE
        order_id NOT IN (
          SELECT
            order_id
          FROM
            user_actions
          WHERE
            action = 'cancel_order'
        )
      ORDER BY
        date
    ) t2 -- дата, юзер, количество его заказов в день
  WHERE
    daily_orders_count = 1
)
SELECT
  date,
  ROUND(
    single_order_users / total_users :: DECIMAL * 100,
    2
  ) AS single_order_users_share,
  100 - ROUND(
    single_order_users / total_users :: DECIMAL * 100,
    2
  ) AS several_orders_users_share
FROM
  tab2
  JOIN tab1 USING(date)
ORDER BY
  date


4.3
-- верхняя 'с' - русская, а нижняя - английская
SELECT productid, (Знак нижнего подчеркивания перед айди есть, но нормально не отображается отчего-то)
       name
FROM   products
WHERE  name like 'с%'
   and name not like 'c%  %';

2.4
-- уберите TRIM, оставив только TO_CHAR. Не знаю, что он делает, но, похоже, задачу сдать мешает
WITH
new_users_t AS (
    SELECT
        COUNT(DISTINCT user_id) AS new_users,
        TRIM(BOTH FROM TO_CHAR(time, 'Day')) AS week_days,
        DATE_PART('isodow', time) AS isodow
    FROM
        user_actions
    WHERE
        time::date > '2022-08-25' AND time::date < '2022-09-09'
    GROUP BY
        week_days,
        isodow
),
arppu_t AS (
    SELECT
        COUNT(DISTINCT user_id) AS arppu,
        TRIM(BOTH FROM TO_CHAR(time, 'Day')) AS week_days
    FROM
        user_actions
    WHERE
        order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')
        AND time::date > '2022-08-25'
        AND time::date < '2022-09-09'
    GROUP BY
        week_days
),
order_per_day_t AS (
    SELECT
        COUNT(order_id) AS order_per_day,
        TRIM(BOTH FROM TO_CHAR(creation_time, 'Day')) AS week_days
    FROM
        orders
    WHERE
        order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')
        AND creation_time::date > '2022-08-25'
        AND creation_time::date < '2022-09-09'
    GROUP BY
        week_days
),
revenue_per_day_t AS (
    SELECT
        A.week_days,
        SUM(B.price) AS revenue_per_day
    FROM (
        SELECT
            TRIM(BOTH FROM TO_CHAR(creation_time, 'Day')) AS week_days,
            UNNEST(product_ids) AS product_id
        FROM
            orders
        WHERE
            order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')
            AND creation_time::date > '2022-08-25'
            AND creation_time::date < '2022-09-09'
    ) AS A
    LEFT JOIN
        products AS B ON A.product_id = B.product_id
    GROUP BY
        A.week_days
)
SELECT
    A.week_days AS weekday,
    ROUND(A.isodow::decimal,1) AS weekday_number,
    ROUND(C.revenue_per_day::decimal / A.new_users, 2) AS arpu,
    ROUND(C.revenue_per_day::decimal / D.arppu, 2) AS arppu,
    ROUND(C.revenue_per_day::decimal / B.order_per_day, 2) AS aov
FROM
    new_users_t AS A
FULL JOIN
    order_per_day_t AS B ON A.week_days = B.week_days
FULL JOIN
    revenue_per_day_t AS C ON A.week_days = C.week_days
FULL JOIN
    arppu_t AS D ON A.week_days = D.week_days
ORDER BY
    A.isodow;

10.18
-- перед нахождением медианы, вроде, по цене отсортировать надо.
-- Интересно, какой проверочный тест на нечетное число строк... (у чела код прошел тест на нечетное число строк)
WITH t3 AS (SELECT RANK() OVER(ORDER BY order_id) AS rank_id, date, order_price
FROM (SELECT DISTINCT order_id, date, SUM(price) OVER (PARTITION BY order_id) AS order_price
FROM (SELECT order_id, creation_time::DATE AS date, unnest(product_ids) AS product_id
FROM orders
WHERE order_id NOT IN (SELECT order_id FROM user_actions WHERE action = 'cancel_order')) t1
LEFT JOIN products USING (product_id)) t2)


SELECT
    DISTINCT CASE
    WHEN (SELECT MAX(rank_id) FROM t3) % 2 = 1 THEN (SELECT order_price FROM t3 WHERE rank_id = (SELECT MAX(rank_id) FROM t3) / 2 + 1)
    WHEN (SELECT MAX(rank_id) FROM t3) % 2 = 0 THEN ((SELECT order_price FROM t3 WHERE rank_id = (SELECT MAX(rank_id) FROM t3) / 2) + (SELECT order_price FROM t3 WHERE rank_id = (SELECT MAX(rank_id) FROM t3) / 2 + 1))::DECIMAL / 2.0
    END AS median_price
FROM t3


5.16
-- Прикольно:
SELECT(
    (SELECT COUNT(DISTINCT user_id) FROM user_actions),
    (SELECT COUNT(DISTINCT user_id) FROM users)
)
-- (21401,20331)
-- Используйте только таблицу user_actions


7.20
-- С датой. Можно, например, наверное, 'YYYY-MM-DD'. Но можно просто: min(time)::date
-- По второму полю идею не совсем понял. Учитывается ли, что клиент мог первый раз заказать и отменить,
-- но в тот же день заказать (и не отменить) еще раз? Считается ли каждый клиент только один раз?
SELECT
  TO_CHAR(time1, 'YYYY/MM/DD') AS date,
  COUNT(order_id) AS first_orders
FROM
  (
    SELECT
      MIN(time) AS time1,
      order_id
    FROM
      user_actions
    WHERE
      user_id IN (
        SELECT
          user_id
        FROM
          user_actions
        WHERE
          action NOT IN ('cancel_order')
        GROUP BY
          user_id
        HAVING
          COUNT(DISTINCT action) = 1
      )
    GROUP BY
      order_id
  ) subquery
GROUP BY
  date
ORDER BY
  date


7.23
-- а случаи, когда у вас в заказе два дорогих товара обрабатываются?
-- Достаточно добавить distinct в основном selectе
with t as (
  Select
    distinct order_id,
    product_ids,
    unnest(product_ids) product_id
  from
    orders
),
t2 as (
  Select
    order_id,
    product_ids,
    product_id
  from
    t
)
Select
  order_id,
  product_ids
from
  t2
where
  product_id in (
    Select
      product_id
    from
      products
    order by
      price desc
    limit
      5
  )
order by


10.13
не совсем понимаю зачем нужен запрос t.
А если 2 разных пользователя одновременно совершат заказ? В вашем случае, вроде, даже три.
select COUNT(*)
from orders
where order_id between 35758 and 35760
group by creation_time
Поэтому скачок от 7 заказов сразу в 10. У двух других пользователей, наверняка, тоже так
select user_id, order_id, action, time,
        coalesce(created_orders, 0)::int created_orders,
        coalesce(canceled_orders, 0)::int canceled_orders,
        coalesce(round(canceled_orders/(created_orders), 2), 0) cancel_rate
from
        (select user_id, order_id, action, time,
                sum(count_order) filter (where action='create_order')
                over (partition by user_id order by time rows between unbounded preceding and current row) created_orders,
                sum(count_order) filter (where action='cancel_order')
                over (partition by user_id order by time rows between unbounded preceding and current row) canceled_orders,
                sum(count_order)
                over (partition by user_id order by time rows between unbounded preceding and unbounded following) sum_user_orders
        from
            (select user_id, order_id, action, time,
                    count(order_id) over (partition by time) count_order
            from user_actions
            order by  user_id, order_id, time) as t) as t2
LIMIT 1000


1.5 opiumbit
Количество заказов вы считаете, вроде, верно - с учетом отмен.
Но первый день пользователя в сервисе надо выяснять *без* их учета.
Я, вроде, использовал WHERE IN, а стоило, как здесь сделать LEFT JOIN.
with
not_cancel as (
SELECT DATE(time) AS date, user_id, order_id
FROM   user_actions
WHERE  order_id not in (SELECT order_id
                        FROM   user_actions
                        WHERE  action = 'cancel_order')),

subquery1 AS (
SELECT date, user_id
FROM (
    SELECT DATE(time) AS date, user_id, ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY time)
    FROM user_actions
    ORDER BY user_id, date
    ) t
WHERE row_number = 1
ORDER BY user_id, date),

subquery2 AS (
SELECT date, user_id, COUNT(order_id)
FROM not_cancel
GROUP BY user_id, date
ORDER BY user_id, date)

SELECT A.date, SUM(coalesce(B.count, 0))
FROM subquery1 AS A
LEFT JOIN subquery2 AS B
ON A.user_id = B.user_id AND A.date = B.date
GROUP BY A.date

1.5  meowbite
with
    t as (
        select
            time::DATE as date,
            count(*) as t1
        from
            user_actions
        where
            order_id in (select order_id from user_actions group by order_id having count(*)<2)
        group by
            time::DATE
    ),

    t1 as (
        select
            date,
            count(user_id) as t2
        from (
            select user_id, min(time::date) as date
            from user_actions
            where order_id in (select order_id from user_actions group by order_id having count(*)<2)
            group by user_id
            ) x
        group
            by date
    ),

    t2 as (
        select
            time::date as date,
            count(distinct order_id) as t3
        from (
            select
                *,
                RANK() over(partition by user_id order by time::date asc) as rnk
            from
                (select
                    time::date,
                    user_id,
                    order_id,
                    count(action) as cnt
                from
                    user_actions
                group by
                    time::date,
                    user_id,
                    order_id
                ) x
            ) x1
        where
            rnk = 1
            and cnt = 1
        group by
            time::date
    )

select
    t.date,
    t1 as orders,
    t2 as first_orders ,
    t3 as new_users_orders ,
    round((t2::decimal/t1::decimal) * 100, 2) as first_orders_share,
    round((t3::decimal/t1::decimal) * 100, 2) as new_users_orders_share
from
    t
    join t1 on t.date=t1.date
    join t2 on t1.date=t2.date
order by
    1

2.2
пользователь делает заказ 28-го, но отменяет его 29-го и больше заказов 29-го не делает.
Он в этом коде не считается, а должен.
with
    t1 as
    (select
        creation_time::date date,
        order_id,
        unnest(product_ids) as product_id
    from orders)

    , t2 as
    (select
        date,
        t1.product_id,
        price,
        order_id,
        user_id
    from t1  -- поскольку дату заказа берем по его созданию, то информация о времени снятия заказа пропадает
    left join products using (product_id)
    left join user_actions using (order_id)
    order by date)

    , t3 as
    (select
        date,
        sum (price) filter (where order_id not in (select order_id from user_actions where action like '%cancel%')) as revenue,
        count (DISTINCT user_id) as users,  -- вот здесь неправильно считаем
        count (DISTINCT order_id) filter (where order_id not in (select order_id from user_actions where action like '%cancel%')) as total_orders,
        count (DISTINCT user_id) filter (where order_id not in (select order_id from user_actions where action like '%cancel%')) as paying_users
    from t2
    group by date)

select
    date,
    round (revenue::decimal/users, 2) as arpu,
    round (revenue::decimal/paying_users,2) as arppu,
    round (revenue::decimal/total_orders,2) as aov
from t3
order by date
