# OUTER JOINS с условиями в ON
на примере LEFT JOIN

Я наконец-то окончательно понял как работает LEFT JOIN!  
~~как минимум в третий раз~~

Возможно, я понимаю что-то неверно, поэтому восприми это как мое "имхо".  

В ON может быть три типа условий:
1)	условия только с полем из правой таблицы;
2)	условия только с полем из левой таблицы;
3)	условия со сравнением полей и из правой, и из левой таблицы.

Пайплайн выполнения джойна:
1)	Безвозвратно удаляем из рассмотрения строки правой таблицы по условию 1, получая таблицу П;
2)	Делим строки левой таблицы на 2 группы: проходящие и нет по условию 2 (Л1 и Л2 соответственно);
3)	Иннерджойним таблицы П и Л1;
4)	Если есть строки в Л1, не поучаствовавшие в иннерджойне (не нашлось парных ключей в правой таблице), 
переносим их в Л2. Cтроки в правой таблице, не поучаствовавшие в иннерджойне, безвозвратно выбрасываем;
5)	Подсоединяем к получившейся Л2 столбики из правой таблицы, заполняя значения нуллами;
6)	Строки из пп. 3 и 5 и являются ответом.

Если есть условие типа 1, то оно само по себе не приводит к появлению строк с нуллами вместо значений из другой таблицы.

Для примера возьмем 2 таблицы:

id_L | 	key_L         |	data_L |	param_L  
- |----------------| - | -   
1 | 	    pair      |	a0 |	    0 
2 | 	    pair      |	a1 |	    1
3 | 	    pair      |	a2 |	    1
4 | 	    aloneL    |	b |	    1
5 | 	    filteredL |	c |	0

id_R |	key_R |	data_R |	param_R
- |----------------| - | -   
1 |	    pair |	d0 |	    0
2 |	    pair |	d1 |	    1
3 |	    pair |	d2 |	    1
4 |	    aloneR |	e |	    1
5 |	    filteredR |	f |	0

```sql
WITH 
    L AS (
        SELECT 1 AS id_L, 'pair' AS key_L, 'a0' AS data_L, 0 AS param_L UNION
        SELECT 2, 'pair', 'a1', 1 UNION
        SELECT 3, 'pair', 'a2', 1 UNION
        SELECT 4, 'aloneL', 'b', 1 UNION
        SELECT 5, 'filteredL', 'c', 0
    ),

    R AS (
        SELECT 1 AS id_R, 'pair' AS key_R, 'd0' AS data_R, 0 AS param_R UNION
        SELECT 2, 'pair', 'd1', 1 UNION
        SELECT 3, 'pair', 'd2', 1 UNION
        SELECT 4, 'aloneR', 'e', 1 UNION
        SELECT 5, 'filteredR', 'f', 0
    )

SELECT
    *
FROM
    L 
    LEFT JOIN R 
        ON 
            key_L = key_R
            AND param_L = 1
            AND param_R = 1
ORDER BY
    data_L, 
    data_R
```

Пройдемся по пайплайну выполнения джойна:
1) *выбрасываем* строки 1 и 5 из правой таблицы;
2) в группу Л1 попадают строки 2-4 левой таблицы, в Л2 - строки 1 и 5;
3) по совпадению ключей "pair" получаем 2 ∙ 2 = 4 строки;
4) строку 4 из левой таблицы, не имеющую пары, *переносим* в группу Л2. 
А вот строку 4 правой таблицы просто *выбрасываем*;
5) три строки из группы Л2 будут пополнены нуллами вместо значений полей из правой таблицы;
6) в итоге в ответе семь строк: четыре из п.3 и три из п.5. 
